---
title: "Enrichment Correlation"
output: html_document
---

```{r global_options, include=FALSE, echo=FALSE}
library(knitr)
knitr::opts_chunk$set(echo=TRUE, include=TRUE)
```

# Load paths and libraries
```{r include=FALSE}
source("shared_functions.R")
source("combined_config.R")

library(dplyr)
library(ggplot2)
library(DESeq2)
library(tibble)

fig_palette="Dark2"
```

# Analysis with Normalized Counts
## Load STAR Count Data
```{r}
starout_2019_dir %>%
  list.files(pattern = paste0("_2018_.*",count_suffix,"$"), full.names = TRUE) %>%
  loadStarCounts ->
  genecounts_2019_run

starout_2018_dir %>%
  list.files(pattern = paste0(count_suffix,"$"), full.names = TRUE) %>%
  loadStarCounts ->
  genecounts_2018_run
```

## Load Data in DESeq2
### Make Metadata dataframe for DESeq
```{r}
genecounts_2018_run %>%
  dplyr::select(expid) %>%
  dplyr::mutate(library=str_extract(expid, "^\\d+_[A-Z]+_[A-Z]"),
         exp_year=2018,
         enrichment_rep="1") %>%
  tidyr::separate(library, 
           into = c("RNA_sample_num", "enrichment_method",NA),
           sep="_", remove=FALSE) ->
  sample_df_2018

# knitr::kable(sample_df_2018)
```

```{r}
genecounts_2019_run %>%
  select(expid) %>%
  mutate(library=str_extract(expid, "^\\d+_2018_[A-Z]+_[HMT]\\d"),
         exp_year=2019) %>%
  separate(library, 
           into = c("RNA_sample_num", NA, NA,"method_rep"),
           sep="_", remove=FALSE) %>%
  separate(method_rep, 
           into = c("enrichment_method", "enrichment_rep"),
           sep=1) ->
  sample_df_2019
knitr::kable(sample_df_2019)
 

bind_rows(sample_df_2018, sample_df_2019) %>%
  mutate(enrichment_method = case_when(enrichment_method == "H" ~ "RNase H",
                                       enrichment_method %in% c("T","TOT") ~ "Unenriched",
                                       enrichment_method %in% c("M","MA") ~ "Poly(A)",
                                       enrichment_method == "RZ" ~ "Ribo-Zero")) %>%
  mutate(enrichment_method=factor(enrichment_method, 
                                  levels = c("Unenriched", "RNase H", "Ribo-Zero", "Poly(A)"))) %>%
  column_to_rownames(var="expid") ->
  sample_df
# knitr::kable(sample_df)
```

### Make Count Matrix for DESeq
```{r}
bind_rows(genecounts_2018_run, genecounts_2019_run) %>%
  # drop rRNA and rRNA homologs
  select(-all_of(strand_specific_rrna_homologs)) %>%
  column_to_rownames(var="expid") %>%
  as.matrix %>%
  t ->
  genecounts_for_desesq
# genecounts_for_desesq[1:6,1:6]
```

### Make DESeq object
```{r}
stopifnot(all(rownames(sample_df) == colnames(genecounts_for_desesq))) # Confirm that sample metadata and count columns are in the same order

DESeqDataSetFromMatrix(countData = genecounts_for_desesq,
                       colData = sample_df,
                       design = ~ enrichment_method) ->
  dds
colData(dds)

# Collapse Replicates
dds %>% collapseReplicates(object=., 
                           groupby=colData(.) %>% 
                             as_tibble %>%
                             pull(library)) ->
  dds
dds
```

```{r}
dds <- DESeq(dds)
```

## Calculate Group Mean of Normalized counts

```{r}
dds %>%
  counts(normalized=TRUE) ->
  norm_counts

norm_counts %>%
  as_tibble(rownames = "geneid") %>%
  mutate(gold_mean = rowMeans(select(., matches("_TOT_|_T1")))) ->
  norm_counts_wmeans
```

# Correlations of all Libraries with Average Unenriched
## Pearson R Correlation

```{r}
enrichedCorrelationToGoldStandard <- function(norm_counts_wmeans, dds) {
  norm_counts_wmeans %>%
    select(-geneid) %>%
    summarise_all(.funs=cor, y=pull(., gold_mean)) %>%
    t %>%
    as_tibble(rownames = "library", .name_repair="universal") %>%
    dplyr::rename(cor_with_unenriched="...1") ->
    pearson_df
  
  dds %>%
    colData %>%
    as_tibble %>%
    left_join(pearson_df, by="library") %>%
    filter(enrichment_method!="Unenriched") ->
  pearson_df
  return(pearson_df)
}

pearson_df = enrichedCorrelationToGoldStandard(norm_counts_wmeans, dds)
```


Pearson correlation of each library with the "Gold Standard".

For each library per gene read counts were normalized by that library's total reads mapped to annotated genes (excluding rRNA genes and genes that recruit rRNA reads). An "gold standard" per gene read count was calculated as the average normalized count across the six unenriched libraries.  The Pearson correlation was then calculated between this gold standard and the normalized gene counts for each library.  All unenriched libraries are highly correlated with the gold standard unenriched, indicating that biological and technical replicates are all very similar.  The RNase H libraries are better correlated with the gold standard than Ribo Zero libraries and Poly A libraries, with Poly A libraries having the worst correlation.

## Leave-one-out Correlation for Unenriched
do "cross validation" mean
calculate mean of leave one out set, then correlate the left out with with mean of other 5

### Calculate Cross Correlations
```{r}
norm_counts %>%
  as_tibble(rownames = "geneid") %>%
  select(., matches("_TOT_|_T1")) ->
  unenriched_norm_counts
```

```{r}
calculateCrossCorrelation <- function(unenriched_norm_counts, dds) {
  data.frame(row.names = colnames(unenriched_norm_counts),
         cor_with_unenriched = rep(-1, ncol(unenriched_norm_counts))) ->
    unenriched_cor
  
  for (cur_sample in colnames(unenriched_norm_counts)){
    # print(cur_sample)
    unenriched_norm_counts %>%
      select(-cur_sample) %>%
      rowMeans %>%
      cor(select(unenriched_norm_counts, all_of(cur_sample))) ->
      unenriched_cor[cur_sample,"cor_with_unenriched"]
  }
  unenriched_cor %>%
    as_tibble(rownames = "library", .name_repair="universal") ->
    unenriched_cor
  
  dds %>%
    colData %>%
    as_tibble %>%
    right_join(unenriched_cor, by="library") ->
    unenriched_cor
  
  return(unenriched_cor)
}
calculateCrossCorrelation(unenriched_norm_counts, dds)
```

### Plot Correlations
```{r}
# Find range of R values so plots have the same y-range
bind_rows(unenriched_cor, pearson_df) ->
  all_sample_correlations

all_sample_correlations %>%
  pull(cor_with_unenriched) %>%
  range ->
  r_range

dds %>%
  colData %>%
  as_tibble %>%
  pull(enrichment_method) %>%
  levels ->
  enrich_levels

set.seed(3)
unenriched_cor %>%
  ggplot(aes(x=enrichment_method, y=cor_with_unenriched, color=enrichment_method)) +
  geom_boxplot(fill=NA, color="grey70",outlier.color = NA, width=0.5) +
  geom_jitter(width=0.2, height=0, size = 4, stroke = 1, alpha=0.5) +
  scale_colour_brewer(palette = fig_palette, guide = FALSE, drop=TRUE, limits = enrich_levels) +
  labs(x="Enrichment Method", y="Correlation") +
  theme_minimal() +
  ylim(r_range) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) ->
  unenriched_plot

set.seed(3)
pearson_df %>%  
  ggplot(aes(x=enrichment_method, y=cor_with_unenriched, color=enrichment_method)) +
  geom_boxplot(fill=NA, color="grey70",outlier.color = NA, width=0.5) +
  geom_jitter(width=0.2, height=0, size = 4, stroke = 1, alpha=0.5) +
  scale_colour_brewer(palette = fig_palette, guide = FALSE, drop=TRUE, limits = enrich_levels) +
  labs(x="Enrichment Method", y="Correlation") +
  theme_minimal() +
  ylim(r_range) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) ->
  enriched_plot
```

```{r}
all_sample_correlations %>%
  group_by(enrichment_method) %>%
  summarise(min_r = min(cor_with_unenriched),
            max_r = max(cor_with_unenriched)) %>%
  kable
```

```{r fig.width=2, fig.height=5}  
unenriched_plot
```

```{r fig.width=4, fig.height=5}  
enriched_plot
```

TODO:
1. Make correlation and scatter plots for ncRNA and protein_coding
  A. wrap plotting in function(s)

# Supplementary Scatter Facet
## Prep data for plotting
```{r}
norm_counts_wmeans %>%
  pivot_longer(
    cols = c(-geneid, -gold_mean),
    names_to = "library",
    values_to = "norm_count"
  ) ->
  norm_counts_long

dds %>%
  colData %>%
  as_tibble %>%
  select(-sizeFactor) %>%
  left_join(norm_counts_long, by="library") ->
  norm_counts_long
# knitr::kable(norm_counts_long)
```

## Check technical replicates
```{r}
norm_counts_long %>%
  filter(enrichment_rep != 2) %>%
  filter(!(enrichment_method %in% c("Poly(A)","Unenriched") &
             exp_year == 2018)) %>%
  select(RNA_sample_num, enrichment_method, exp_year, enrichment_rep) %>%
  table
```

## Make Plots
```{r}
norm_counts_long %>%
  # only plot one tech rep per library: remove RNAseH rep2 and Poly A and Unenriched from 2018
  filter(enrichment_rep != 2) %>%
  filter(!(enrichment_method %in% c("Poly(A)","Unenriched") &
             exp_year == 2018)) %>%
  filter(enrichment_method!="Unenriched") %>%
  ggplot(aes(x=gold_mean, y=norm_count, color=enrichment_method)) +
  geom_point(alpha=0.3) +
  labs(x = "Average Normalized Count in Unenriched", y= "Normalized Count") +
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) ->
  all_library_scatterplot
```

### Sample x Enrichment Facetted Scatter Plot

```{r fig.width=8, fig.height=8}  
all_library_scatterplot +
  facet_grid(enrichment_method ~ RNA_sample_num) +
  scale_colour_brewer(palette = fig_palette, guide = FALSE, drop=TRUE, limits = enrich_levels) +
  geom_abline()
```

For each library per gene read counts were normalized by that library's total reads mapped to annotated genes (excluding rRNA genes and genes that recruit rRNA reads). A "gold standard" per gene read count was calculated as the average normalized count across the six unenriched libraries.  Libraries for each enrichment method applied to each biological replicate are ploted (technical replicates are not shown).  Each point represents a gene with the gold standard count as the x value, and the normalized count from a library as the y value.


# SessionInfo
```{r}
sessionInfo()
```

