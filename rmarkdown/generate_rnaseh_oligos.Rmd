---
title: "Generate Oligos"
output:
  html_document:
    toc: false
---

# Setup
## Load Libraries
```{r}
# library(Rsamtools)
# library(ggbio)
# library(fs)
# library(GenomicAlignments)
# library(tidyverse)
# library(plyr)
library(rtracklayer)
```

## Load Data
```{r}
source("run_config.R")

h99_genome = readDNAStringSet(fa.file)
# Strip descriptions from chrom names
h99_genome %>%
  names %>%
  str_extract("\\w+") ->
  names(h99_genome)

# 
# seq_dir = "/workspace/2018_tot_samples/seq_out"
# genome_dir = "/workspace/2018_tot_samples/genome/"
# h99_gtf.file = "/workspace/2018_tot_samples/genome/Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf"
# 
# 
# 
# 
# h99_gtf.file %>%
#   path_file %>%
#   path_ext_remove %>%
#   paste0("__with_mito_rrna.gtf") %>%
#   file.path(seq_dir, .) ->
#   new_gtf.file
```

```{r eval=FALSE, include=FALSE}
rtrack = import.gff2(gtf_with_mito_rrna.file)
rtrack = rtrack[ rtrack$gene_biotype=="rRNA" ]
rtrack = rtrack[ rtrack$type=="exon" ]
rtrack
```

## Subset rRNA granges



```{r}
import.gff2(gtf_with_mito_rrna.file) %>%
  .[.$gene_biotype=="rRNA" ] %>%
  .[.$type=="exon" ] ->
  rrna.gr
rrna.gr
```


## Extract rRNA Sequences
```{r}
# rrna.gr[1] 
rrna.seq1 = getSeq(h99_genome, rrna.gr[1]) %>%
  reverseComplement

# rrna.seq1 = getSeq(h99_genome, rrna.gr["small_mito_rRNA"])
rrna.seq1
```

## Reverse Complement rRNA Sequences

## Partition Sequences into oligos
```{r}
oligo_length = 50

cur_rrna.seq = getSeq(h99_genome, rrna.gr[4]) %>%
  reverseComplement

cat("rRNA gene Length:", width(cur_rrna.seq), fill = TRUE)
# account for the fact that most sequences will not be divisible by oligo_length by gapping some oligos by 1 base

cat("------ Gapped oligo iranges --------", fill = TRUE)
gapped_oligo_count = (width(cur_rrna.seq) %% oligo_length) + 1




gapped.ir = successiveIRanges(rep(oligo_length, gapped_oligo_count), gapwidth = 1)
gapped.ir.end = max(end(gapped.ir))

if (gapped.ir.end <= width(cur_rrna.seq)){
  cat("Number of gapped oligos:", gapped_oligo_count, fill = TRUE)

  # (width(cur_rrna.seq) - ungapped.ir.start)
  gapped.ir

  cat("------ UNgapped oligo iranges --------", fill = TRUE)
  ungapped.ir.start = gapped.ir.end + 1

  ungapped_oligo_count = (((width(cur_rrna.seq) - ungapped.ir.start) + 1) / oligo_length)

  cat("Number of UNgapped oligos:", ungapped_oligo_count, fill = TRUE)
  ungapped.ir = successiveIRanges(rep(oligo_length, ungapped_oligo_count), gapwidth = 0, from=ungapped.ir.start)
  ungapped.ir

  combined.ir = c(gapped.ir, ungapped.ir)
  combined.ir
} else {
  # if the rRNA fragment isn't large enough to accomodate all of the gapped oligos
  # 
  stop("Gotta figure something else out!")
}


```
```{r}
oligo_length = 50


generateGappedIRanges = function(sequence, oligo_length, gapwidth=1) {
  # seqeunce can be a BioString or an integer representing the sequence length
  if (is.numeric(sequence)){
    cur_seqlen = sequence
  } else {
    cur_seqlen = width(sequence)
  }
  cat("rRNA gene Length:", cur_seqlen, fill = TRUE)
  
  # account for the fact that most sequences will not be divisible by oligo_length by gapping some oligos by 1 base
  cat("------ Gapped oligo iranges --------", fill = TRUE)
  gapped_oligo_count = (cur_seqlen %% oligo_length) + 1
  if ((gapped_oligo_count * oligo_length) > cur_seqlen){
    gapped_oligo_count = cur_seqlen %/% oligo_length
  }

  gapped.ir = successiveIRanges(rep(oligo_length, gapped_oligo_count), gapwidth = gapwidth)
  gapped.ir.end = max(end(gapped.ir))
  
  cat("Number of gapped oligos:", gapped_oligo_count, fill = TRUE)

  # (cur_seqlen - ungapped.ir.start)
  print(gapped.ir)

  cat("------ UNgapped oligo iranges --------", fill = TRUE)
  ungapped.ir.start = gapped.ir.end + 1

  ungapped_oligo_count = (((cur_seqlen - ungapped.ir.start) + 1) %/% oligo_length)

  cat("Number of UNgapped oligos:", ungapped_oligo_count, fill = TRUE)
  ungapped.ir = successiveIRanges(rep(oligo_length, ungapped_oligo_count), gapwidth = 0, from=ungapped.ir.start)
  print(ungapped.ir)

  combined.ir = c(gapped.ir, ungapped.ir)
  combined.ir.end = max(end(combined.ir))
  uncovered_3_prime = cur_seqlen - combined.ir.end
    
  print(combined.ir)
  cat("Number of Uncovered 3' bases:", uncovered_3_prime)
  return(combined.ir)
}
```


```{r}
cur_rrna.seq = getSeq(h99_genome, rrna.gr[3]) %>%
  reverseComplement
x = generateGappedIRanges(cur_rrna.seq, oligo_length)

# generateGappedIRanges(111, oligo_length, gapwidth = 1)
```

```{r}

rrna.gr[4]
cur_rrna.seq = getSeq(h99_genome, rrna.gr[4]) %>%
  reverseComplement
x = generateGappedIRanges(cur_rrna.seq, oligo_length, gapwidth = 6)

cat("For CNAG_10503 we use a gap of 6bp, which leaves 5bp uncovered at the 3' end, since it is too short for gap adjustment with gapwidth=1", fill = TRUE)
```



```{r}
max(end(gapped.ir))
```


```{r}
breakInChunks(1001, chunksize=50)
```


```{r}
successiveIRanges(rep(50, 1000))
length(rrna.seq1)
extractAt(rrna.seq1, successiveIRanges(rep(50, 10))) ->
  x
x
# 
# %>%
#   writeXStringSet("test.fasta")
as.data.frame(x)
```

## Name Oligos

## Output Oligos



# Cruft


```{r}
###################################################
### code chunk number 27: makeTxDbFromGFF_1
###################################################
library(GenomicFeatures)
gtf_file <- new_gtf.file
txdb <- makeTxDbFromGFF(gtf_file, format="gtf")
txdb


###################################################
### code chunk number 28: makeTxDbFromGFF_2
###################################################
exonsBy(txdb, by="gene")

```

```{r}
keytypes(txdb)
columns(txdb)
```

