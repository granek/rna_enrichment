---
title: "Generate Oligos"
output:
  html_document:
    toc: false
---

# Setup
## Load Libraries
```{r}
library(tidyverse)
library(BSgenome)
library(rtracklayer)
library(Biostrings)
```

## Load Data
Load H99 genome and rename chromosomes to chromosome ID only. readDNAStringSet uses the whole header line, including the description text, as the sequence name, whereas STAR uses only the sequence ID (the part before the first whitespace).  We need to strip the description text (stuff after the whitespace) so that GTF identifiers match with sequence identifiers.
```{r}
source("run_config.R")

h99_genome = readDNAStringSet(fa.file)
# Strip descriptions from chrom names
h99_genome %>%
  names %>%
  str_extract("\\w+") ->
  names(h99_genome)
```

## Subset rRNA granges
Pull out the rRNA exons only.
```{r}
import.gff2(gtf_with_mito_rrna.file) %>%
  .[.$gene_biotype=="rRNA" ] %>%
  .[.$type=="exon" ] ->
  rrna.gr
rrna.gr
```

## Extract rRNA Sequences
```{r eval=FALSE, include=FALSE}
# rrna.gr[1] 
rrna.seq1 = getSeq(h99_genome, rrna.gr[1]) %>%
  reverseComplement

rrna.seq1
```


## Partition Sequences into oligos
### Generate Oligo IRanges

```{r}
generateGappedIRanges = function(sequence, oligo_length=50, gapwidth=1) {
  # seqeunce can be a BioString or an integer representing the sequence length
  if (is.numeric(sequence)){
    cur_seqlen = sequence
  } else {
    cur_seqlen = width(sequence)
  }
  cat("rRNA gene Length:", cur_seqlen, fill = TRUE)
  
  # account for the fact that most sequences will not be divisible by oligo_length by gapping some oligos by 1 base
  cat("------ Gapped oligo iranges --------", fill = TRUE)
  gapped_oligo_count = (cur_seqlen %% oligo_length) + 1
  if ((gapped_oligo_count * oligo_length) > cur_seqlen){
    gapped_oligo_count = cur_seqlen %/% oligo_length
  }

  gapped.ir = successiveIRanges(rep(oligo_length, gapped_oligo_count), gapwidth = gapwidth)
  gapped.ir.end = max(end(gapped.ir))
  
  cat("Number of gapped oligos:", gapped_oligo_count, fill = TRUE)

  # (cur_seqlen - ungapped.ir.start)
  print(gapped.ir)

  cat("------ UNgapped oligo iranges --------", fill = TRUE)
  ungapped.ir.start = gapped.ir.end + 1

  ungapped_oligo_count = (((cur_seqlen - ungapped.ir.start) + 1) %/% oligo_length)

  cat("Number of UNgapped oligos:", ungapped_oligo_count, fill = TRUE)
  ungapped.ir = successiveIRanges(rep(oligo_length, ungapped_oligo_count), gapwidth = 0, from=ungapped.ir.start)
  print(ungapped.ir)

  combined.ir = c(gapped.ir, ungapped.ir)
  combined.ir.end = max(end(combined.ir))
  uncovered_3_prime = cur_seqlen - combined.ir.end
    
  print(combined.ir)
  cat("Number of Uncovered 3' bases:", uncovered_3_prime)
  return(combined.ir)
}
```

```{r eval=FALSE, include=FALSE}
cur_rrna.seq = getSeq(h99_genome, rrna.gr[3]) %>%
  reverseComplement
x = generateGappedIRanges(cur_rrna.seq, oligo_length)

# generateGappedIRanges(111, oligo_length, gapwidth = 1)
```

```{r eval=FALSE, include=FALSE}
cur.gr = rrna.gr[4]
cur.seq = getSeq(h99_genome, cur.gr) %>%
  reverseComplement
cur.ir = generateGappedIRanges(cur.seq, oligo_length, gapwidth = 6)

cat("For CNAG_10503 we use a gap of 6bp, which leaves 5bp uncovered at the 3' end, since it is too short for gap adjustment with gapwidth=1", fill = TRUE)
```


```{r eval=FALSE, include=FALSE}
extractAt(cur.seq, cur.ir) %>%
  as.data.frame(x) %>%
  dplyr::mutate(ID = paste(cur.gr$gene_id, row_number(), sep="__")) %>%
  select(ID, oligo_sequence=value)
```

```{r}
generateOligos = function(cur.grange, genome, oligo_length=50, gapwidth=1){
  cur.seq = getSeq(genome, cur.grange) %>%
    reverseComplement
  
  cur.ir = generateGappedIRanges(cur.seq, oligo_length, gapwidth)
  
  extractAt(cur.seq, cur.ir) %>%
    as.data.frame %>%
    dplyr::mutate(ID = paste(cur.grange$gene_id, row_number(), sep="__")) %>%
    select(ID, oligo_sequence=value) %>%
    return
}
```

```{r eval=FALSE, include=FALSE}
generateOligos(rrna.gr[1], h99_genome)
```
```{r eval=FALSE, include=FALSE}
length(rrna.gr)
rrna.gr %>%
  .[seq_along(.)[-4]]

# %>%
#   map_dfr(.x=., .f=generateOligos, genome=h99_genome)
```

```{r eval=FALSE, include=FALSE}
do.call(cbind, 
        lapply(rrna.gr %>%
                 .[seq_along(.)[-4]],
               generateOligos, 
               genome=h99_genome)
)
```

```{r}
CNAG_10503_index = which(rrna.gr$gene_id=="CNAG_10503")

all_oligos.df = generateOligos(rrna.gr[CNAG_10503_index], genome=h99_genome, gapwidth = 6)

cat("For CNAG_10503 we use a gap of 6bp, which leaves 5bp uncovered at the 3' end, since it is too short for gap adjustment with gapwidth=1", fill = TRUE)

# others.gr = rrna.gr %>% .[]

# cur.seq = getSeq(h99_genome, cur.gr) %>%
#   reverseComplement
# cur.ir = generateGappedIRanges(cur.seq, oligo_length, gapwidth = 6)

# for (cur.gr in ){
#     next_oligos = generateOligos(cur.gr, genome=h99_genome, gapwidth = 1)
#     all_oligos.df = cbind(all_oligos.df, next_oligos)
# }
# all_oligos.df
for (i in seq_along(rrna.gr)[-CNAG_10503_index]){
  print(i)
  next_oligos = generateOligos(rrna.gr[i], genome=h99_genome, gapwidth = 1)
  all_oligos.df = rbind(all_oligos.df, next_oligos)
  # print(cur.gr)
}
# for (cur.gr in ){
#     
#     all_oligos.df = cbind(all_oligos.df, next_oligos)
# }
all_oligos.df
```


# Play Chunks

```{r eval=FALSE, include=FALSE}
extractAt(cur.seq, cur.ir) %>%
  as.data.frame(x) -> 
  cur.oligos

cur.oligos
cur.gr$gene_id
cur.oligos %>%
  dplyr::mutate(ID = row_number())
  # mutate(id = row_number())
  # mutate( paste(cur.gr$gene_id, seq(nrow(.)), sep="_")
# nrow(cur.oligos)
```

```{r eval=FALSE, include=FALSE}
breakInChunks(1001, chunksize=50)
```


```{r eval=FALSE, include=FALSE}
successiveIRanges(rep(50, 1000))
length(rrna.seq1)
extractAt(rrna.seq1, successiveIRanges(rep(50, 10))) ->
  x
x
# 
# %>%
#   writeXStringSet("test.fasta")
as.data.frame(x)
```

## Name Oligos

## Output Oligos



# Cruft


```{r eval=FALSE, include=FALSE}
###################################################
### code chunk number 27: makeTxDbFromGFF_1
###################################################
library(GenomicFeatures)
gtf_file <- new_gtf.file
txdb <- makeTxDbFromGFF(gtf_file, format="gtf")
txdb


###################################################
### code chunk number 28: makeTxDbFromGFF_2
###################################################
exonsBy(txdb, by="gene")

```

```{r eval=FALSE, include=FALSE}
keytypes(txdb)
columns(txdb)
```

