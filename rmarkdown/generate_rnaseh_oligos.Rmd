---
title: "Generate Oligos"
output:
  html_document:
    toc: false
---

# Setup
## Load Libraries
```{r}
# library(Rsamtools)
# library(ggbio)
# library(fs)
# library(GenomicAlignments)
# library(tidyverse)
# library(plyr)
library(BSgenome)
library(rtracklayer)
library(Biostrings)
```

## Load Data
```{r}
source("run_config.R")

h99_genome = readDNAStringSet(fa.file)
# Strip descriptions from chrom names
h99_genome %>%
  names %>%
  str_extract("\\w+") ->
  names(h99_genome)
```

## Subset rRNA granges
```{r}
import.gff2(gtf_with_mito_rrna.file) %>%
  .[.$gene_biotype=="rRNA" ] %>%
  .[.$type=="exon" ] ->
  rrna.gr
rrna.gr
```


## Extract rRNA Sequences
```{r}
# rrna.gr[1] 
rrna.seq1 = getSeq(h99_genome, rrna.gr[1]) %>%
  reverseComplement

rrna.seq1
```

## Reverse Complement rRNA Sequences

## Partition Sequences into oligos
### Generate Oligo IRanges

```{r}
oligo_length = 50


generateGappedIRanges = function(sequence, oligo_length, gapwidth=1) {
  # seqeunce can be a BioString or an integer representing the sequence length
  if (is.numeric(sequence)){
    cur_seqlen = sequence
  } else {
    cur_seqlen = width(sequence)
  }
  cat("rRNA gene Length:", cur_seqlen, fill = TRUE)
  
  # account for the fact that most sequences will not be divisible by oligo_length by gapping some oligos by 1 base
  cat("------ Gapped oligo iranges --------", fill = TRUE)
  gapped_oligo_count = (cur_seqlen %% oligo_length) + 1
  if ((gapped_oligo_count * oligo_length) > cur_seqlen){
    gapped_oligo_count = cur_seqlen %/% oligo_length
  }

  gapped.ir = successiveIRanges(rep(oligo_length, gapped_oligo_count), gapwidth = gapwidth)
  gapped.ir.end = max(end(gapped.ir))
  
  cat("Number of gapped oligos:", gapped_oligo_count, fill = TRUE)

  # (cur_seqlen - ungapped.ir.start)
  print(gapped.ir)

  cat("------ UNgapped oligo iranges --------", fill = TRUE)
  ungapped.ir.start = gapped.ir.end + 1

  ungapped_oligo_count = (((cur_seqlen - ungapped.ir.start) + 1) %/% oligo_length)

  cat("Number of UNgapped oligos:", ungapped_oligo_count, fill = TRUE)
  ungapped.ir = successiveIRanges(rep(oligo_length, ungapped_oligo_count), gapwidth = 0, from=ungapped.ir.start)
  print(ungapped.ir)

  combined.ir = c(gapped.ir, ungapped.ir)
  combined.ir.end = max(end(combined.ir))
  uncovered_3_prime = cur_seqlen - combined.ir.end
    
  print(combined.ir)
  cat("Number of Uncovered 3' bases:", uncovered_3_prime)
  return(combined.ir)
}
```

```{r}
cur_rrna.seq = getSeq(h99_genome, rrna.gr[3]) %>%
  reverseComplement
x = generateGappedIRanges(cur_rrna.seq, oligo_length)

# generateGappedIRanges(111, oligo_length, gapwidth = 1)
```

```{r}
rrna.gr[4]
cur_rrna.seq = getSeq(h99_genome, rrna.gr[4]) %>%
  reverseComplement
x = generateGappedIRanges(cur_rrna.seq, oligo_length, gapwidth = 6)

cat("For CNAG_10503 we use a gap of 6bp, which leaves 5bp uncovered at the 3' end, since it is too short for gap adjustment with gapwidth=1", fill = TRUE)
```


```{r}
breakInChunks(1001, chunksize=50)
```


```{r}
successiveIRanges(rep(50, 1000))
length(rrna.seq1)
extractAt(rrna.seq1, successiveIRanges(rep(50, 10))) ->
  x
x
# 
# %>%
#   writeXStringSet("test.fasta")
as.data.frame(x)
```

## Name Oligos

## Output Oligos



# Cruft


```{r eval=FALSE, include=FALSE}
###################################################
### code chunk number 27: makeTxDbFromGFF_1
###################################################
library(GenomicFeatures)
gtf_file <- new_gtf.file
txdb <- makeTxDbFromGFF(gtf_file, format="gtf")
txdb


###################################################
### code chunk number 28: makeTxDbFromGFF_2
###################################################
exonsBy(txdb, by="gene")

```

```{r eval=FALSE, include=FALSE}
keytypes(txdb)
columns(txdb)
```

