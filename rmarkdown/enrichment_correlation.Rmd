---
title: "Enrichment Correlation"
output: html_document
---

# Load paths and libraries
```{r include=FALSE}
source("run_config.R")
library(foreach)
library(tidyverse)
library(magrittr)
library(rtracklayer)
```

## Load STAR Count Data
```{r}
count_suffix = "_ReadsPerGene.out.tab"
countfiles = list.files(starout.dir, pattern = paste0(count_suffix,"$"), full.names = TRUE)
countfiles
```

### Load STAR Count tables into a single dataframe
Loading code borrowed from https://gitlab.oit.duke.edu/HTS2018/HTS2018-notebooks/blob/master/pilot/01_Read_Counts.ipynb
```{r}
mycombine <- function(df1, df2) {
    # Combine two data frames by gene names
    #
    # Args:
    #   df1 (Dataframe): the first count data
    #   df2 (Dataframe): the second count data
    #
    # Returns:
    #   (Dataframe) The combined data frame of df1 and df2
    full_join(df1, df2, by = "gene")
}

# Data type for each column
coltypes <- list(col_character(), col_integer(), col_integer(), col_integer())

out <- foreach(count_path = countfiles, .combine = mycombine) %do% {
  # generate rowname (extracted from count file name)
  count_path %>%
    path_file %>%
    str_replace(count_suffix,"") ->
    readset_label 

    # read in the count file
    readr::read_tsv(count_path, col_names = FALSE, col_types = coltypes) %>%
        dplyr::select(X1, X4) %>% # get the 1st and 4th columns (gene ids and second strand read counts)
            dplyr::rename_(.dots=setNames(names(.), c("gene",readset_label)))
}

out[1:6,1:6]

# Drop STAR count statistics and rotate dataframe
out %>%
    dplyr::slice(-(1:4)) %>%
    gather(expid, value, -gene) %>% 
    spread(gene, value) -> genecounts

genecounts[1:6,1:6]
```

### Extract library specific label
```{r}
genecounts %>%
  mutate(Label=str_extract(expid, "^\\d+_[A-Z]+_[A-Z]")) %>%
  dplyr::select(Label, everything()) %>%
  dplyr::select(-expid) ->
  genecounts_with_label
genecounts_with_label[1:8,1:6]
```

### Combine per library counts across lanes
```{r}
genecounts_with_label %>%
  group_by(Label) %>%
  summarise_all(funs(sum)) ->
  genecounts_lanes_combined

# Add metadata 
read_tsv(metadata.file) %>%
  dplyr::select(Label, enrichment_method, RNA_sample_num) ->
  metadata.df

genecounts_lanes_combined %<>%
  left_join(metadata.df, by="Label") %>%
  dplyr::select(library=Label, enrichment_method, RNA_sample_num, everything())
genecounts_lanes_combined[,1:6]
```

## Compare library preps

### Drop rRNA genes and genes with rRNA homology

#### Find all genes that are mapped by rRNA reads
##### Load GTF
```{r}
import(gtf_with_mito_rrna.file, format="gtf") %>%
  subset(type=="exon") ->
  h99_granges
```


##### Find all genes that overlap with rRNA reads
https://bioinformatics.stackexchange.com/questions/874/intersection-of-two-genomic-ranges-to-keep-metadata
```{r}
scanBam(oligo_bam.file) %>%
  as.data.frame %>%
  mutate(end=pos+qwidth) %>%
  dplyr::select(chr=rname, start=pos, end, strand) %>%
  makeGRangesFromDataFrame(ignore.strand = TRUE) %>%
  invertStrand -> # we invert the strand since the oligos are antisense
  oligo_bam.gr

# %>% rev
  # oligo_gene_counts

o = findOverlaps(h99_granges, oligo_bam.gr)
grl1 = split(h99_granges[queryHits(o)], 1:length(o)) # You can't mendoapply on a GRanges object
grl2 = split(oligo_bam.gr[subjectHits(o)], 1:length(o))
foo = function(x, y) {
  rv = x
  start(rv) = max(start(x), start(y))
  end(rv) = min(end(x), end(y))
  return(rv)
}

unlist(mendoapply(foo, grl1, y=grl2)) %>%
  as.data.frame %>%
  pull(gene_id) %>%
  unique ->
  all_rrna_homologs

all_rrna_homologs
```

##### Find STRAND-SPECIFIC genes that overlap with rRNA reads
```{r}
scanBam(oligo_bam.file) %>%
  as.data.frame %>%
  mutate(end=pos+qwidth) %>%
  dplyr::select(chr=rname, start=pos, end, strand) %>%
  makeGRangesFromDataFrame %>%
  invertStrand -> # we invert the strand since the oligos are antisense
  oligo_bam.gr

# %>% rev
  # oligo_gene_counts

o = findOverlaps(h99_granges, oligo_bam.gr)
grl1 = split(h99_granges[queryHits(o)], 1:length(o)) # You can't mendoapply on a GRanges object
grl2 = split(oligo_bam.gr[subjectHits(o)], 1:length(o))
foo = function(x, y) {
  rv = x
  start(rv) = max(start(x), start(y))
  end(rv) = min(end(x), end(y))
  return(rv)
}

unlist(mendoapply(foo, grl1, y=grl2)) %>%
  as.data.frame %>%
  pull(gene_id) %>%
  unique ->
  strand_specific_rrna_homologs

strand_specific_rrna_homologs
```

#### Drop genes from count table

small_MTrRNA and large_MTrRNA are not present in current STAR count files because it was run with the ensembl version of GTF.  Need to run with the custom version that includes small_MTrRNA and large_MTrRNA, but first need to do some refactoring

Need to:
1. rename (MITO_RRNA_STAR_OUT -> RRNA_OLIGO_STAROUT) in all files
2. rename (mito_rrna_star_out.dir -> rrna_oligo_star_out.dir)
3. change run_star_on_total_samples.Rmd so that it *only runs on total samples* (with gtf from ensembl)
4. create run_star_on_enrich_compare_samples.Rmd
5. Test run with CUSTOM version of GTF that includes mito rRNA
6. run on all enrichment comparison libraries (samples 2, 3, and 4) with CUSTOM version of GTF that includes mito rRNA

```{r}
# genes_to_drop = intersect(colnames(genecounts_lanes_combined), 
#                           strand_specific_rrna_homologs)
genecounts_lanes_combined %>%
  dplyr::select(strand_specific_rrna_homologs) ->
  check_select

check_select[,1:6]

genecounts_lanes_combined %>%
  dplyr::select(-strand_specific_rrna_homologs) ->
  genecounts_lanes_combined_no_rrna
```


### Generate scatterplots for MA vs TOT and RZ vs TOT 

### Generate correlation coefficients for MA vs TOT and RZ vs TOT

