---
title: "Enrichment Correlation"
output: html_document
---

# Load paths and libraries
```{r include=FALSE}
source("run_config.R")
library(foreach)
library(dplyr)
library(tidyr)
library(magrittr)
library(rtracklayer)
library(ggplot2)
library(gridExtra)
library(readr)
library(stringr)
library(Rsamtools)
```

## Load STAR Count Data
```{r}
countfiles = list.files(enrich_compare_starout.dir, pattern = paste0(count_suffix,"$"), full.names = TRUE)
countfiles
```

### Load STAR Count tables into a single dataframe
Loading code borrowed from https://gitlab.oit.duke.edu/HTS2018/HTS2018-notebooks/blob/master/pilot/01_Read_Counts.ipynb
```{r}
mycombine <- function(df1, df2) {
    # Combine two data frames by gene names
    #
    # Args:
    #   df1 (Dataframe): the first count data
    #   df2 (Dataframe): the second count data
    #
    # Returns:
    #   (Dataframe) The combined data frame of df1 and df2
    full_join(df1, df2, by = "gene")
}

# Data type for each column
coltypes <- list(col_character(), col_integer(), col_integer(), col_integer())

out <- foreach(count_path = countfiles, .combine = mycombine) %do% {
  # generate rowname (extracted from count file name)
  count_path %>%
    path_file %>%
    str_replace(count_suffix,"") ->
    readset_label 

    # read in the count file
    readr::read_tsv(count_path, col_names = FALSE, col_types = coltypes) %>%
        dplyr::select(X1, X4) %>% # get the 1st and 4th columns (gene ids and second strand read counts)
            dplyr::rename_(.dots=setNames(names(.), c("gene",readset_label)))
}

out[1:6,1:6]

# Drop STAR count statistics and rotate dataframe
out %>%
    dplyr::slice(-(1:4)) %>%
    gather(expid, value, -gene) %>% 
    spread(gene, value) -> genecounts

genecounts[1:6,1:6]
```

### Extract library specific label
```{r}
genecounts %>%
  mutate(Label=str_extract(expid, "^\\d+_[A-Z]+_[A-Z]")) %>%
  dplyr::select(Label, everything()) %>%
  dplyr::select(-expid) ->
  genecounts_with_label
genecounts_with_label[1:8,1:6]
```

### Combine per library counts across lanes
```{r}
genecounts_with_label %>%
  group_by(Label) %>%
  summarise_all(funs(sum)) ->
  genecounts_lanes_combined

# Add metadata 
read_tsv(metadata.file) %>%
  dplyr::select(Label, enrichment_method, RNA_sample_num) ->
  metadata.df

genecounts_lanes_combined %<>%
  left_join(metadata.df, by="Label") %>%
  dplyr::select(library=Label, enrichment_method, RNA_sample_num, everything())
genecounts_lanes_combined[,1:6]
```

## Compare library preps

### Drop rRNA genes and genes with rRNA homology

#### Find all genes that are mapped by rRNA reads
##### Load GTF
```{r}
import(gtf_with_mito_rrna.file, format="gtf") %>%
  subset(type=="exon") ->
  h99_granges
```


##### Find all genes that overlap with rRNA reads
https://bioinformatics.stackexchange.com/questions/874/intersection-of-two-genomic-ranges-to-keep-metadata
```{r}
scanBam(oligo_bam.file) %>%
  as.data.frame %>%
  mutate(end=pos+qwidth) %>%
  dplyr::select(chr=rname, start=pos, end, strand) %>%
  makeGRangesFromDataFrame(ignore.strand = TRUE) %>%
  invertStrand -> # we invert the strand since the oligos are antisense
  oligo_bam.gr

# %>% rev
  # oligo_gene_counts

o = findOverlaps(h99_granges, oligo_bam.gr)
grl1 = split(h99_granges[queryHits(o)], 1:length(o)) # You can't mendoapply on a GRanges object
grl2 = split(oligo_bam.gr[subjectHits(o)], 1:length(o))
foo = function(x, y) {
  rv = x
  start(rv) = max(start(x), start(y))
  end(rv) = min(end(x), end(y))
  return(rv)
}

unlist(mendoapply(foo, grl1, y=grl2)) %>%
  as.data.frame %>%
  pull(gene_id) %>%
  unique ->
  all_rrna_homologs

all_rrna_homologs
```

##### Find STRAND-SPECIFIC genes that overlap with rRNA reads
```{r}
scanBam(oligo_bam.file) %>%
  as.data.frame %>%
  mutate(end=pos+qwidth) %>%
  dplyr::select(chr=rname, start=pos, end, strand) %>%
  makeGRangesFromDataFrame %>%
  invertStrand -> # we invert the strand since the oligos are antisense
  oligo_bam.gr

# %>% rev
  # oligo_gene_counts

o = findOverlaps(h99_granges, oligo_bam.gr)
grl1 = split(h99_granges[queryHits(o)], 1:length(o)) # You can't mendoapply on a GRanges object
grl2 = split(oligo_bam.gr[subjectHits(o)], 1:length(o))
foo = function(x, y) {
  rv = x
  start(rv) = max(start(x), start(y))
  end(rv) = min(end(x), end(y))
  return(rv)
}

unlist(mendoapply(foo, grl1, y=grl2)) %>%
  as.data.frame %>%
  pull(gene_id) %>%
  unique ->
  strand_specific_rrna_homologs

strand_specific_rrna_homologs
```

#### Drop genes from count table

small_MTrRNA and large_MTrRNA are not present in current STAR count files because it was run with the ensembl version of GTF.  Need to run with the custom version that includes small_MTrRNA and large_MTrRNA, but first need to do some refactoring

Need to:
1. rename (MITO_RRNA_STAR_OUT -> RRNA_OLIGO_STAROUT) in all files
2. rename (mito_rrna_star_out.dir -> rrna_oligo_star_out.dir)
3. change run_star_on_total_samples.Rmd so that it *only runs on total samples* (with gtf from ensembl)
4. create run_star_on_enrich_compare_samples.Rmd
5. Test run with CUSTOM version of GTF that includes mito rRNA
6. run on all enrichment comparison libraries (samples 2, 3, and 4) with CUSTOM version of GTF that includes mito rRNA

```{r}
# genes_to_drop = intersect(colnames(genecounts_lanes_combined), 
#                           strand_specific_rrna_homologs)
genecounts_lanes_combined %>%
  dplyr::select(strand_specific_rrna_homologs) ->
  check_select

check_select[,1:6]

genecounts_lanes_combined %>%
  dplyr::select(-strand_specific_rrna_homologs) ->
  genecounts_lanes_combined_no_rrna

genecounts_lanes_combined_no_rrna[,1:6]

dim(check_select)
dim(genecounts_lanes_combined)
dim(genecounts_lanes_combined_no_rrna)

dplyr::select(genecounts_lanes_combined,small_MTrRNA)
# dplyr::select(genecounts_lanes_combined_no_rrna,small_MTrRNA)

```


### Generate scatterplots for MA vs TOT and RZ vs TOT
```{r}
genecounts_lanes_combined_no_rrna[,1:6]

```

```{r}

cur_sample_num = 2

genecounts_lanes_combined_no_rrna %>%
  filter(RNA_sample_num == cur_sample_num) %>%
  dplyr::select(-c(library,RNA_sample_num)) %>%
  gather(gene_id, reads, 2:ncol(.)) %>%
  spread(enrichment_method,reads) ->
  cur_sample.tidy
  
title_text = paste0("Sample #", cur_sample_num, collapse=" ")

cur_sample.tidy %>%
  summarise(max(MA), max(RZ)) %>%
  max -> ymax

tot_vs_ma = ggplot(cur_sample.tidy, aes(TOT, MA)) + 
  geom_point(alpha = 1/2, color="red", size=1) +
  ggtitle(title_text) +
  theme_bw() +
  ylim(0, ymax)
tot_vs_rz = ggplot(cur_sample.tidy, aes(TOT, RZ)) + 
  geom_point(alpha = 1/2, color="red", size=1) +
  ggtitle(title_text) +
  theme_bw() +
  ylim(0, ymax)

grid.arrange(tot_vs_ma, tot_vs_rz, nrow = 1)


ggplot(cur_sample.tidy, aes(TOT, y=value, color=variable, alpha = 1/2)) + 
  geom_point(aes(y=MA, color="MA"), size=1) +
  geom_point(aes(y=RZ, color="RZ"), size=1) +
  ggtitle(title_text) +
  theme_bw()



ggplot(cur_sample.tidy, alpha = 1/2) +
  geom_point(aes(TOT, MA), color="red", size=1) + 
  geom_smooth(aes(TOT, MA), method=lm, se=FALSE, color="red") +
  geom_point(aes(TOT, RZ), color="blue", size=1) +
  geom_smooth(aes(TOT, RZ), method=lm, se=FALSE, color="blue") +
  ggtitle(title_text) +
  theme_bw() 
```

https://www.sixhat.net/how-to-plot-multpile-data-series-with-ggplot.html

library(reshape)
# This creates a new data frame with columns x, variable and value
# x is the id, variable holds each of our timeseries designation
 
ggplot(data = df.melted, aes(x = x, y = value, color = variable)) +
  geom_point()
And thats how to plot multiple data series using ggplot. The basic trick is that you need to melt your data into a new data.frame. Remember, in data.frames each row represents an observation.

update:

Another option, pointed to me in the comments by Cosmin Saveanu (Thanks!), it to plot the multiple data series with facets (good for B&W):

library(reshape)
ggplot(data = df.melted, aes(x = x, y = value)) +
geom_point() + facet_grid(variable ~ .)





# Drop STAR count statistics and rotate dataframe
out %>%
    dplyr::slice(-(1:4)) %>%
    gather(expid, value, -gene) %>% 
    spread(gene, value) -> genecounts

genecounts[1:6,1:6]




### Generate correlation coefficients for MA vs TOT and RZ vs TOT

